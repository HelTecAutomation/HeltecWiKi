const fs = require('fs');
const path = require('path');

/**
 * 检查目录是否有索引文档（与目录名相同的 md/mdx 文件）
 */
function hasIndexDocument(dirPath, dirName) {
  const mdFile = path.join(dirPath, `${dirName}.md`);
  const mdxFile = path.join(dirPath, `${dirName}.mdx`);
  return fs.existsSync(mdFile) || fs.existsSync(mdxFile);
}

/**
 * 获取目录的索引文档 ID
 * 索引文档的 ID 应该是完整路径，包括文件名
 * 例如：devices/general-docs/general-docs
 */
function getIndexDocumentId(relativePath) {
  // 相对路径已经包含了目录名，我们需要添加文件名（与目录名相同）
  const pathParts = relativePath.split(/[/\\]/);
  const dirName = pathParts[pathParts.length - 1];
  // 返回完整路径，包括文件名
  return `${relativePath}/${dirName}`.replace(/\\/g, '/');
}

/**
 * 检查文件是否是索引文档（与目录名相同）
 */
function isIndexDocument(fileName, dirName) {
  const baseName = path.basename(fileName, path.extname(fileName));
  return baseName === dirName;
}

/**
 * 递归构建侧边栏结构，为每个有索引文档的目录添加 Introduction
 * @param {string} dirPath - 目录的完整路径
 * @param {string} relativePath - 相对于 docs 的路径
 * @param {string} dirName - 目录名
 * @returns {Array} 侧边栏配置项
 */
function buildSidebarItems(dirPath, relativePath, dirName) {
  const items = [];
  
  if (!fs.existsSync(dirPath)) {
    return items;
  }

  const entries = fs.readdirSync(dirPath, { withFileTypes: true })
    .filter(entry => {
      // 跳过 img 目录、node_modules 和隐藏文件
      return entry.name !== 'img' && 
             entry.name !== 'node_modules' && 
             !entry.name.startsWith('.');
    })
    .sort((a, b) => {
      // 目录排在前面
      if (a.isDirectory() !== b.isDirectory()) {
        return a.isDirectory() ? -1 : 1;
      }
      return a.name.localeCompare(b.name);
    });

  // 如果当前目录有索引文档，先添加 Introduction
  if (hasIndexDocument(dirPath, dirName)) {
    const docId = getIndexDocumentId(relativePath);
    items.push({
      type: 'doc',
      id: docId,
      label: 'Introduction',
    });
  }

  // 处理子目录和文件
  const subCategories = [];
  const docFiles = [];

  for (const entry of entries) {
    if (entry.isDirectory()) {
      const fullPath = path.join(dirPath, entry.name);
      const newRelativePath = relativePath ? `${relativePath}/${entry.name}` : entry.name;
      
      // 递归处理子目录
      const subItems = buildSidebarItems(fullPath, newRelativePath, entry.name);
      
      if (subItems.length > 0) {
        subCategories.push({
          type: 'category',
          label: entry.name,
          items: subItems,
        });
      }
    } else if (entry.isFile() && /\.(md|mdx)$/i.test(entry.name)) {
      // 跳过索引文档（已经作为 Introduction 添加了）
      if (!isIndexDocument(entry.name, dirName)) {
        const fileBaseName = path.basename(entry.name, path.extname(entry.name));
        const docId = relativePath 
          ? `${relativePath}/${fileBaseName}`.replace(/\\/g, '/')
          : fileBaseName;
        docFiles.push({
          type: 'doc',
          id: docId,
        });
      }
    }
  }

  // 先添加文档文件，再添加子目录
  items.push(...docFiles);
  items.push(...subCategories);

  return items;
}

/**
 * 为指定的目录生成侧边栏配置
 * 在每个有索引文档的 category 开头添加 Introduction
 */
function generateSidebarWithIntroductions(docsDir, dirName) {
  const targetDir = path.join(docsDir, dirName);
  
  if (!fs.existsSync(targetDir)) {
    return [{ type: 'autogenerated', dirName }];
  }
  
  // 构建侧边栏结构
  const items = buildSidebarItems(targetDir, dirName, dirName);
  
  return items;
}

module.exports = { generateSidebarWithIntroductions };
